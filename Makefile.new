# Production-Grade Load Balancer Makefile
# Implements industry best practices for Go projects and 12-Factor App compliance
.PHONY: help build run test clean docker-build docker-run docker-stop deps lint format security audit benchmark
.DEFAULT_GOAL := help

# Project Configuration
BINARY_NAME := load-balancer
DOCKER_IMAGE := load-balancer
DOCKER_TAG := latest
MODULE_NAME := github.com/mir00r/load-balancer

# Build Information
GIT_COMMIT := $(shell git rev-parse --short HEAD)
GIT_BRANCH := $(shell git rev-parse --abbrev-ref HEAD)
BUILD_TIME := $(shell date -u +%Y-%m-%dT%H:%M:%SZ)
VERSION := $(shell git describe --tags --always --dirty)
GO_VERSION := $(shell go version | awk '{print $$3}')

# Directories
BUILD_DIR := build
BIN_DIR := bin
DOCS_DIR := docs
COVERAGE_DIR := coverage

# Go Configuration
GOCMD := go
GOBUILD := $(GOCMD) build
GOCLEAN := $(GOCMD) clean
GOTEST := $(GOCMD) test
GOGET := $(GOCMD) get
GOMOD := $(GOCMD) mod
GOFMT := gofmt
GOLINT := golangci-lint

# Build Flags
BUILD_FLAGS := -trimpath -mod=readonly
LDFLAGS := -ldflags="-w -s \
	-X $(MODULE_NAME)/internal/version.Version=$(VERSION) \
	-X $(MODULE_NAME)/internal/version.GitCommit=$(GIT_COMMIT) \
	-X $(MODULE_NAME)/internal/version.GitBranch=$(GIT_BRANCH) \
	-X $(MODULE_NAME)/internal/version.BuildTime=$(BUILD_TIME) \
	-X $(MODULE_NAME)/internal/version.GoVersion=$(GO_VERSION)"

# Test Configuration
TEST_TIMEOUT := 300s
TEST_COVERAGE_THRESHOLD := 80
BENCHMARK_TIME := 10s

# Docker Configuration
DOCKERFILE := Dockerfile
DOCKER_CONTEXT := .

# Colors for output
COLOR_RESET := \033[0m
COLOR_BOLD := \033[1m
COLOR_RED := \033[31m
COLOR_GREEN := \033[32m
COLOR_YELLOW := \033[33m
COLOR_BLUE := \033[34m
COLOR_MAGENTA := \033[35m
COLOR_CYAN := \033[36m

## Help
help: ## Display this help message
	@echo "$(COLOR_BOLD)$(COLOR_BLUE)Load Balancer - Production Build System$(COLOR_RESET)"
	@echo ""
	@echo "$(COLOR_BOLD)Available Commands:$(COLOR_RESET)"
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  $(COLOR_CYAN)%-20s$(COLOR_RESET) %s\n", $$1, $$2}' $(MAKEFILE_LIST)
	@echo ""
	@echo "$(COLOR_BOLD)Build Information:$(COLOR_RESET)"
	@echo "  Version:     $(COLOR_GREEN)$(VERSION)$(COLOR_RESET)"
	@echo "  Git Commit:  $(COLOR_GREEN)$(GIT_COMMIT)$(COLOR_RESET)"
	@echo "  Git Branch:  $(COLOR_GREEN)$(GIT_BRANCH)$(COLOR_RESET)"
	@echo "  Go Version:  $(COLOR_GREEN)$(GO_VERSION)$(COLOR_RESET)"

## Development Commands

deps: ## Install and verify dependencies
	@echo "$(COLOR_YELLOW)Installing dependencies...$(COLOR_RESET)"
	$(GOMOD) download
	$(GOMOD) verify
	$(GOMOD) tidy
	@echo "$(COLOR_GREEN)Dependencies installed successfully$(COLOR_RESET)"

deps-update: ## Update all dependencies to latest versions
	@echo "$(COLOR_YELLOW)Updating dependencies...$(COLOR_RESET)"
	$(GOGET) -u ./...
	$(GOMOD) tidy
	@echo "$(COLOR_GREEN)Dependencies updated successfully$(COLOR_RESET)"

dev-setup: deps ## Setup development environment
	@echo "$(COLOR_YELLOW)Setting up development environment...$(COLOR_RESET)"
	@if ! command -v golangci-lint >/dev/null 2>&1; then \
		echo "Installing golangci-lint..."; \
		curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $$(go env GOPATH)/bin v1.55.2; \
	fi
	@if ! command -v govulncheck >/dev/null 2>&1; then \
		echo "Installing govulncheck..."; \
		go install golang.org/x/vuln/cmd/govulncheck@latest; \
	fi
	@if ! command -v gotestsum >/dev/null 2>&1; then \
		echo "Installing gotestsum..."; \
		go install gotest.tools/gotestsum@latest; \
	fi
	@echo "$(COLOR_GREEN)Development environment setup complete$(COLOR_RESET)"

## Build Commands

build: deps ## Build the application for current platform
	@echo "$(COLOR_YELLOW)Building $(BINARY_NAME)...$(COLOR_RESET)"
	@mkdir -p $(BUILD_DIR)
	$(GOBUILD) $(BUILD_FLAGS) $(LDFLAGS) -o $(BUILD_DIR)/$(BINARY_NAME) ./cmd/server
	@echo "$(COLOR_GREEN)Build completed: $(BUILD_DIR)/$(BINARY_NAME)$(COLOR_RESET)"

build-all: deps ## Build for all supported platforms
	@echo "$(COLOR_YELLOW)Building for all platforms...$(COLOR_RESET)"
	@mkdir -p $(BUILD_DIR)
	@for os in linux darwin windows; do \
		for arch in amd64 arm64; do \
			if [ "$$os" = "windows" ]; then ext=".exe"; else ext=""; fi; \
			echo "Building $$os/$$arch..."; \
			GOOS=$$os GOARCH=$$arch CGO_ENABLED=0 $(GOBUILD) $(BUILD_FLAGS) $(LDFLAGS) \
				-o $(BUILD_DIR)/$(BINARY_NAME)-$$os-$$arch$$ext ./cmd/server; \
		done; \
	done
	@echo "$(COLOR_GREEN)Multi-platform build completed$(COLOR_RESET)"

build-production: deps ## Build optimized production binary
	@echo "$(COLOR_YELLOW)Building production binary...$(COLOR_RESET)"
	@mkdir -p $(BUILD_DIR)
	CGO_ENABLED=0 GOOS=linux GOARCH=amd64 $(GOBUILD) \
		$(BUILD_FLAGS) $(LDFLAGS) \
		-tags netgo,osusergo \
		-o $(BUILD_DIR)/$(BINARY_NAME)-production \
		./cmd/server
	@echo "$(COLOR_GREEN)Production build completed$(COLOR_RESET)"

install: build ## Install binary to GOPATH/bin
	@echo "$(COLOR_YELLOW)Installing $(BINARY_NAME)...$(COLOR_RESET)"
	@mkdir -p $(shell go env GOPATH)/bin
	@cp $(BUILD_DIR)/$(BINARY_NAME) $(shell go env GOPATH)/bin/
	@echo "$(COLOR_GREEN)Installation completed$(COLOR_RESET)"

## Development & Running

run: build ## Run the application
	@echo "$(COLOR_YELLOW)Starting $(BINARY_NAME)...$(COLOR_RESET)"
	@if [ -f .env ]; then export $$(cat .env | grep -v '^#' | xargs); fi && \
	./$(BUILD_DIR)/$(BINARY_NAME)

dev: ## Run in development mode with live reload
	@echo "$(COLOR_YELLOW)Starting development server...$(COLOR_RESET)"
	@if [ -f .env ]; then export $$(cat .env | grep -v '^#' | xargs); fi && \
	$(GOCMD) run ./cmd/server

hot-reload: ## Run with file watching (requires air)
	@if ! command -v air >/dev/null 2>&1; then \
		echo "Installing air for hot reload..."; \
		go install github.com/cosmtrek/air@latest; \
	fi
	@echo "$(COLOR_YELLOW)Starting hot reload server...$(COLOR_RESET)"
	air

## Testing Commands

test: ## Run all tests
	@echo "$(COLOR_YELLOW)Running tests...$(COLOR_RESET)"
	@mkdir -p $(COVERAGE_DIR)
	$(GOTEST) -v -race -timeout $(TEST_TIMEOUT) -coverprofile=$(COVERAGE_DIR)/coverage.out ./...
	@echo "$(COLOR_GREEN)Tests completed$(COLOR_RESET)"

test-unit: ## Run unit tests only
	@echo "$(COLOR_YELLOW)Running unit tests...$(COLOR_RESET)"
	$(GOTEST) -v -race -short -timeout 60s ./internal/...

test-integration: ## Run integration tests only
	@echo "$(COLOR_YELLOW)Running integration tests...$(COLOR_RESET)"
	$(GOTEST) -v -race -timeout $(TEST_TIMEOUT) ./tests/integration/...

test-load: ## Run load tests
	@echo "$(COLOR_YELLOW)Running load tests...$(COLOR_RESET)"
	$(GOTEST) -v -timeout $(TEST_TIMEOUT) ./tests/load/...

test-security: ## Run security tests
	@echo "$(COLOR_YELLOW)Running security tests...$(COLOR_RESET)"
	$(GOTEST) -v -timeout 120s ./tests/security/...

test-coverage: test ## Run tests and generate coverage report
	@echo "$(COLOR_YELLOW)Generating coverage report...$(COLOR_RESET)"
	@mkdir -p $(COVERAGE_DIR)
	$(GOCMD) tool cover -html=$(COVERAGE_DIR)/coverage.out -o $(COVERAGE_DIR)/coverage.html
	$(GOCMD) tool cover -func=$(COVERAGE_DIR)/coverage.out | tail -1
	@echo "$(COLOR_GREEN)Coverage report generated: $(COVERAGE_DIR)/coverage.html$(COLOR_RESET)"

test-coverage-ci: ## Generate coverage for CI (with threshold check)
	@echo "$(COLOR_YELLOW)Running coverage analysis...$(COLOR_RESET)"
	@mkdir -p $(COVERAGE_DIR)
	$(GOTEST) -v -race -timeout $(TEST_TIMEOUT) -coverprofile=$(COVERAGE_DIR)/coverage.out ./...
	@coverage=$$($(GOCMD) tool cover -func=$(COVERAGE_DIR)/coverage.out | tail -1 | awk '{print $$3}' | sed 's/%//'); \
	echo "Coverage: $$coverage%"; \
	if [ $$(echo "$$coverage < $(TEST_COVERAGE_THRESHOLD)" | bc -l) -eq 1 ]; then \
		echo "$(COLOR_RED)Coverage $$coverage% is below threshold $(TEST_COVERAGE_THRESHOLD)%$(COLOR_RESET)"; \
		exit 1; \
	else \
		echo "$(COLOR_GREEN)Coverage $$coverage% meets threshold $(TEST_COVERAGE_THRESHOLD)%$(COLOR_RESET)"; \
	fi

benchmark: ## Run performance benchmarks
	@echo "$(COLOR_YELLOW)Running benchmarks...$(COLOR_RESET)"
	@mkdir -p $(COVERAGE_DIR)
	$(GOTEST) -bench=. -benchmem -benchtime=$(BENCHMARK_TIME) \
		-cpuprofile=$(COVERAGE_DIR)/cpu.prof \
		-memprofile=$(COVERAGE_DIR)/mem.prof \
		./...
	@echo "$(COLOR_GREEN)Benchmarks completed$(COLOR_RESET)"

## Code Quality Commands

lint: ## Run linter
	@echo "$(COLOR_YELLOW)Running linter...$(COLOR_RESET)"
	$(GOLINT) run --timeout=5m ./...
	@echo "$(COLOR_GREEN)Linting completed$(COLOR_RESET)"

lint-fix: ## Run linter with auto-fix
	@echo "$(COLOR_YELLOW)Running linter with auto-fix...$(COLOR_RESET)"
	$(GOLINT) run --fix --timeout=5m ./...
	@echo "$(COLOR_GREEN)Linting and fixing completed$(COLOR_RESET)"

format: ## Format code
	@echo "$(COLOR_YELLOW)Formatting code...$(COLOR_RESET)"
	$(GOFMT) -s -w .
	goimports -w .
	@echo "$(COLOR_GREEN)Code formatting completed$(COLOR_RESET)"

format-check: ## Check if code is formatted
	@echo "$(COLOR_YELLOW)Checking code format...$(COLOR_RESET)"
	@unformatted=$$($(GOFMT) -l .); \
	if [ -n "$$unformatted" ]; then \
		echo "$(COLOR_RED)The following files are not formatted:$(COLOR_RESET)"; \
		echo "$$unformatted"; \
		exit 1; \
	else \
		echo "$(COLOR_GREEN)All files are properly formatted$(COLOR_RESET)"; \
	fi

vet: ## Run go vet
	@echo "$(COLOR_YELLOW)Running go vet...$(COLOR_RESET)"
	$(GOCMD) vet ./...
	@echo "$(COLOR_GREEN)Go vet completed$(COLOR_RESET)"

## Security Commands

security: ## Run security analysis
	@echo "$(COLOR_YELLOW)Running security analysis...$(COLOR_RESET)"
	govulncheck ./...
	@echo "$(COLOR_GREEN)Security analysis completed$(COLOR_RESET)"

audit: security ## Full security audit
	@echo "$(COLOR_YELLOW)Running full security audit...$(COLOR_RESET)"
	$(GOMOD) download
	nancy sleuth --quiet
	@echo "$(COLOR_GREEN)Security audit completed$(COLOR_RESET)"

## Docker Commands

docker-build: ## Build Docker image
	@echo "$(COLOR_YELLOW)Building Docker image...$(COLOR_RESET)"
	docker build -t $(DOCKER_IMAGE):$(DOCKER_TAG) \
		--build-arg VERSION=$(VERSION) \
		--build-arg GIT_COMMIT=$(GIT_COMMIT) \
		--build-arg BUILD_TIME=$(BUILD_TIME) \
		-f $(DOCKERFILE) $(DOCKER_CONTEXT)
	@echo "$(COLOR_GREEN)Docker image built: $(DOCKER_IMAGE):$(DOCKER_TAG)$(COLOR_RESET)"

docker-build-multi: ## Build multi-platform Docker image
	@echo "$(COLOR_YELLOW)Building multi-platform Docker image...$(COLOR_RESET)"
	docker buildx build --platform linux/amd64,linux/arm64 \
		-t $(DOCKER_IMAGE):$(DOCKER_TAG) \
		--build-arg VERSION=$(VERSION) \
		--build-arg GIT_COMMIT=$(GIT_COMMIT) \
		--build-arg BUILD_TIME=$(BUILD_TIME) \
		-f $(DOCKERFILE) $(DOCKER_CONTEXT) \
		--push
	@echo "$(COLOR_GREEN)Multi-platform Docker image built and pushed$(COLOR_RESET)"

docker-run: docker-build ## Run Docker container
	@echo "$(COLOR_YELLOW)Running Docker container...$(COLOR_RESET)"
	docker run -d \
		--name $(BINARY_NAME) \
		-p 8080:8080 \
		-p 8081:8081 \
		-p 9090:9090 \
		--env-file .env \
		$(DOCKER_IMAGE):$(DOCKER_TAG)
	@echo "$(COLOR_GREEN)Docker container started$(COLOR_RESET)"

docker-stop: ## Stop and remove Docker container
	@echo "$(COLOR_YELLOW)Stopping Docker container...$(COLOR_RESET)"
	-docker stop $(BINARY_NAME)
	-docker rm $(BINARY_NAME)
	@echo "$(COLOR_GREEN)Docker container stopped$(COLOR_RESET)"

docker-logs: ## Show Docker container logs
	docker logs -f $(BINARY_NAME)

## Documentation Commands

docs: ## Generate documentation
	@echo "$(COLOR_YELLOW)Generating documentation...$(COLOR_RESET)"
	@mkdir -p $(DOCS_DIR)/api
	$(GOCMD) doc -all ./... > $(DOCS_DIR)/api/godoc.txt
	@echo "$(COLOR_GREEN)Documentation generated$(COLOR_RESET)"

docs-serve: ## Serve documentation locally
	@echo "$(COLOR_YELLOW)Starting documentation server...$(COLOR_RESET)"
	godoc -http=:6060 -play
	@echo "Documentation available at http://localhost:6060"

## CI/CD Commands

ci: deps format-check vet lint test-coverage-ci security ## Full CI pipeline
	@echo "$(COLOR_GREEN)CI pipeline completed successfully$(COLOR_RESET)"

cd: build-production docker-build ## CD pipeline (build artifacts)
	@echo "$(COLOR_GREEN)CD pipeline completed successfully$(COLOR_RESET)"

release: ci cd ## Full release pipeline
	@echo "$(COLOR_GREEN)Release pipeline completed successfully$(COLOR_RESET)"

## Utility Commands

clean: ## Clean build artifacts
	@echo "$(COLOR_YELLOW)Cleaning build artifacts...$(COLOR_RESET)"
	$(GOCLEAN)
	rm -rf $(BUILD_DIR) $(BIN_DIR) $(COVERAGE_DIR)
	-docker rmi $(DOCKER_IMAGE):$(DOCKER_TAG)
	@echo "$(COLOR_GREEN)Cleanup completed$(COLOR_RESET)"

clean-deps: ## Clean dependency cache
	@echo "$(COLOR_YELLOW)Cleaning dependency cache...$(COLOR_RESET)"
	$(GOCLEAN) -modcache
	@echo "$(COLOR_GREEN)Dependency cache cleaned$(COLOR_RESET)"

version: ## Show version information
	@echo "$(COLOR_BOLD)Version Information:$(COLOR_RESET)"
	@echo "  Version:     $(COLOR_GREEN)$(VERSION)$(COLOR_RESET)"
	@echo "  Git Commit:  $(COLOR_GREEN)$(GIT_COMMIT)$(COLOR_RESET)"
	@echo "  Git Branch:  $(COLOR_GREEN)$(GIT_BRANCH)$(COLOR_RESET)"
	@echo "  Build Time:  $(COLOR_GREEN)$(BUILD_TIME)$(COLOR_RESET)"
	@echo "  Go Version:  $(COLOR_GREEN)$(GO_VERSION)$(COLOR_RESET)"

env: ## Show environment information
	@echo "$(COLOR_BOLD)Environment Information:$(COLOR_RESET)"
	@echo "  GOPATH:      $(COLOR_GREEN)$(shell go env GOPATH)$(COLOR_RESET)"
	@echo "  GOROOT:      $(COLOR_GREEN)$(shell go env GOROOT)$(COLOR_RESET)"
	@echo "  GOOS:        $(COLOR_GREEN)$(shell go env GOOS)$(COLOR_RESET)"
	@echo "  GOARCH:      $(COLOR_GREEN)$(shell go env GOARCH)$(COLOR_RESET)"
	@echo "  CGO_ENABLED: $(COLOR_GREEN)$(shell go env CGO_ENABLED)$(COLOR_RESET)"

size: build ## Show binary size information
	@echo "$(COLOR_BOLD)Binary Size Information:$(COLOR_RESET)"
	@ls -lh $(BUILD_DIR)/$(BINARY_NAME) | awk '{print "  Size: $(COLOR_GREEN)" $$5 "$(COLOR_RESET)"}'
	@file $(BUILD_DIR)/$(BINARY_NAME) | cut -d: -f2 | sed 's/^/  Type:$(COLOR_GREEN)/' | sed 's/$$/$(COLOR_RESET)/'

## Development Workflow Commands

quick: format lint test ## Quick development check
	@echo "$(COLOR_GREEN)Quick check completed$(COLOR_RESET)"

full: ci benchmark docs ## Full development check
	@echo "$(COLOR_GREEN)Full check completed$(COLOR_RESET)"

# Development targets for common workflows
dev-test: format vet test-unit ## Quick test during development
dev-check: format vet lint test-unit ## Development check before commit
pre-commit: format-check vet lint test ## Pre-commit validation

# Maintenance commands
update: deps-update test ## Update dependencies and run tests
health-check: version env size ## Check project health
